import { Draft } from 'immer';
export declare type State = {
    readonly [k: string]: any;
};
declare type DidUpdate = (prevState: State, state: State) => void;
declare type WillUpdate = (state: State, nextState: State) => void;
declare class Store {
    private store;
    private readonly didUpdate?;
    private readonly willUpdate?;
    static initialize: (store: Store, keys: string[], initialValue?: unknown) => void;
    static merge(store1: Store, store2: Store): Store;
    constructor(payload?: State, { didUpdate, willUpdate }?: {
        didUpdate?: DidUpdate;
        willUpdate?: WillUpdate;
    });
    getState<S extends State>(): S;
    get<T extends unknown>(key: string): undefined | T;
    has(key: string): boolean;
    update<S extends State>(nextState: S): void;
    produce<S extends State>(producer: (draft: Draft<S>) => void): void;
    merge<S extends State>(payload: Partial<S>): void;
    set<T extends unknown>(key: string, value: T): void;
    delete(key: string): void;
    keys(): string[];
    reduce<T>(callback: (acc: T, value: {
        key: string;
        value: unknown;
    }, index: number) => T, initial: T): T;
    map<T>(callback: (value: {
        key: string;
        value: unknown;
    }, index: number) => T): T[];
    forEach(callback: (value: {
        key: string;
        value: unknown;
    }, index: number) => void): void;
    flush(): void;
}
export default Store;
