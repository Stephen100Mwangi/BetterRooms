"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Action = void 0;
const Lifecycle_1 = require("../Lifecycle");
const cycleStack_1 = __importDefault(require("./cycleStack"));
const Stack_1 = __importDefault(require("./Stack"));
const Store_1 = __importDefault(require("./Store"));
const Trace_1 = __importDefault(require("./Trace"));
const programManager_1 = __importDefault(require("./utils/programManager"));
var Action;
(function (Action) {
    Action[Action["IDLE"] = 0] = "IDLE";
    Action[Action["REQUEST"] = 1] = "REQUEST";
    Action[Action["RESPONSE"] = 2] = "RESPONSE";
    Action[Action["END"] = 3] = "END";
})(Action = exports.Action || (exports.Action = {}));
class Runtime extends Lifecycle_1.AbstractLifecycle {
    constructor(versionID, state, request = null, { services = {}, handlers = [], api }, events) {
        super(events);
        this.versionID = versionID;
        this.request = request;
        this.action = Action.IDLE;
        const createEvent = (type) => (event) => this.callEvent(type, event);
        this.services = services;
        this.handlers = handlers;
        this.api = api;
        this.stack = new Stack_1.default(state.stack, {
            willChange: createEvent(Lifecycle_1.EventType.stackWillChange),
            didChange: createEvent(Lifecycle_1.EventType.stackDidChange),
        });
        this.turn = new Store_1.default(state.turn, {
            didUpdate: createEvent(Lifecycle_1.EventType.turnDidUpdate),
            willUpdate: createEvent(Lifecycle_1.EventType.turnWillUpdate),
        });
        this.storage = new Store_1.default(state.storage, {
            didUpdate: createEvent(Lifecycle_1.EventType.storageDidUpdate),
            willUpdate: createEvent(Lifecycle_1.EventType.storageWillUpdate),
        });
        this.variables = new Store_1.default(state.variables, {
            didUpdate: createEvent(Lifecycle_1.EventType.variablesDidUpdate),
            willUpdate: createEvent(Lifecycle_1.EventType.variablesWillUpdate),
        });
        this.trace = new Trace_1.default(this);
        this.programManager = new programManager_1.default(this);
    }
    getRequest() {
        return this.request;
    }
    setAction(type) {
        this.action = type;
    }
    getAction() {
        return this.action;
    }
    end() {
        this.setAction(Action.END);
    }
    hasEnded() {
        return this.getAction() === Action.END;
    }
    async callEvent(type, event) {
        await super.callEvent(type, event, this);
    }
    getProgram(programID) {
        return this.programManager.get(programID);
    }
    async update() {
        try {
            await this.callEvent(Lifecycle_1.EventType.updateWillExecute, {});
            if (this.action !== Action.IDLE) {
                throw new Error('runtime updated twice');
            }
            this.setAction(this.request ? Action.REQUEST : Action.RESPONSE);
            await cycleStack_1.default(this);
            await this.callEvent(Lifecycle_1.EventType.updateDidExecute, {});
        }
        catch (error) {
            await this.callEvent(Lifecycle_1.EventType.updateDidCatch, { error });
        }
    }
    getFinalState() {
        if (this.action === Action.IDLE) {
            throw new Error('runtime not updated');
        }
        return {
            stack: this.stack.getState(),
            storage: this.storage.getState(),
            variables: this.variables.getState(),
        };
    }
    getRawState() {
        return {
            turn: this.turn.getState(),
            stack: this.stack.getState(),
            storage: this.storage.getState(),
            variables: this.variables.getState(),
        };
    }
    getHandlers() {
        return this.handlers;
    }
    getVersionID() {
        return this.versionID;
    }
}
exports.default = Runtime;
//# sourceMappingURL=index.js.map