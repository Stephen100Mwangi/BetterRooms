"use strict";
/* eslint-disable no-await-in-loop */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HANDLER_OVERFLOW = void 0;
const Lifecycle_1 = require("../Lifecycle");
exports.HANDLER_OVERFLOW = 400;
const cycleHandler = async (runtime, program, variableState) => {
    const referenceFrame = runtime.stack.top();
    const currentFrames = runtime.stack.getFrames();
    let nextID = null;
    let i = 0;
    let node = program.getNode(referenceFrame.getNodeID());
    do {
        if (i > exports.HANDLER_OVERFLOW) {
            node = null;
            break;
        }
        else if (nextID) {
            referenceFrame.setNodeID(nextID);
            node = program.getNode(nextID);
            nextID = null;
        }
        if (node !== null) {
            const _node = node; // resolve TS type
            try {
                const handler = runtime.getHandlers().find((h) => h.canHandle(_node, runtime, variableState, program));
                if (handler) {
                    await runtime.callEvent(Lifecycle_1.EventType.handlerWillHandle, { node, variables: variableState });
                    nextID = await handler.handle(_node, runtime, variableState, program);
                    await runtime.callEvent(Lifecycle_1.EventType.handlerDidHandle, { node, variables: variableState });
                }
            }
            catch (error) {
                await runtime.callEvent(Lifecycle_1.EventType.handlerDidCatch, { error });
            }
            // if a node has decided to stop on itself
            if (node.id === nextID) {
                runtime.end();
            }
            // exit conditions for handler loop
            if (!nextID || runtime.hasEnded() || currentFrames !== runtime.stack.getFrames()) {
                node = null;
            }
        }
        i++;
    } while (node);
};
exports.default = cycleHandler;
//# sourceMappingURL=cycleHandler.js.map