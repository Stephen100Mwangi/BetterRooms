"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Lifecycle_1 = require("../../Lifecycle");
const Program_1 = __importDefault(require("../../Program"));
/**
 * use this class for CPU caching strategies when fetching programs/memory
 * https://en.wikipedia.org/wiki/Cache_replacement_policies
 */
class ProgramManager {
    constructor(runtime) {
        this.runtime = runtime;
        this.cachedProgram = null;
    }
    async get(programID) {
        var _a;
        let program;
        // Event.programWillFetch can optionally override the program
        await this.runtime.callEvent(Lifecycle_1.EventType.programWillFetch, {
            programID,
            override: (_program) => {
                program = _program;
            },
        });
        // this manager currently just caches the current program, incase it is repeatedly called
        if (!program && programID === ((_a = this.cachedProgram) === null || _a === void 0 ? void 0 : _a.getID())) {
            program = this.cachedProgram;
        }
        if (!program) {
            program = new Program_1.default(await this.runtime.api.getProgram(programID));
        }
        this.runtime.callEvent(Lifecycle_1.EventType.programDidFetch, { programID, program });
        this.cachedProgram = program;
        return program;
    }
}
exports.default = ProgramManager;
//# sourceMappingURL=programManager.js.map