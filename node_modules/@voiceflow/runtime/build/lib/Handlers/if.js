"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const general_types_1 = require("@voiceflow/general-types");
const Lifecycle_1 = require("../Lifecycle");
const shuntingYard_1 = require("./utils/shuntingYard");
const IfHandler = () => ({
    canHandle: (node) => !!(node.type !== general_types_1.NodeType.IF_V2 && node.expressions && node.expressions.length < 101),
    handle: async (node, runtime, variables) => {
        var _a;
        for (let i = 0; i < node.expressions.length; i++) {
            try {
                // eslint-disable-next-line no-await-in-loop
                const evaluated = await shuntingYard_1.evaluateExpression(node.expressions[i], {
                    v: variables.getState(),
                });
                runtime.trace.debug(`evaluating path ${i + 1}: \`${shuntingYard_1.regexExpression(node.expressions[i])}\` to \`${(_a = evaluated === null || evaluated === void 0 ? void 0 : evaluated.toString) === null || _a === void 0 ? void 0 : _a.call(evaluated)}\``);
                if (evaluated || evaluated === 0) {
                    runtime.trace.debug(`condition true - taking path ${i + 1}`);
                    return node.nextIds[i];
                }
            }
            catch (error) {
                runtime.trace.debug(`unable to resolve expression \`${shuntingYard_1.regexExpression(node.expressions[i])}\`  \n\`${error}\``);
                // eslint-disable-next-line no-await-in-loop
                await runtime.callEvent(Lifecycle_1.EventType.handlerDidCatch, { error });
            }
        }
        runtime.trace.debug('no conditions matched - taking else path');
        return node.elseId || null;
    },
});
exports.default = IfHandler;
//# sourceMappingURL=if.js.map