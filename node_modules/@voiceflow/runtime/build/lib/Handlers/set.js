"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const general_types_1 = require("@voiceflow/general-types");
const bluebird_1 = __importDefault(require("bluebird"));
const Lifecycle_1 = require("../Lifecycle");
const shuntingYard_1 = require("./utils/shuntingYard");
const setHandler = () => ({
    canHandle: (node) => !!(node.type !== general_types_1.NodeType.SET_V2 && node.sets && node.sets.length < 21),
    handle: async (node, runtime, variables) => {
        await bluebird_1.default.each(node.sets, async (set) => {
            var _a;
            try {
                if (!set.variable)
                    throw new Error('No Variable Defined');
                const evaluated = await shuntingYard_1.evaluateExpression(set.expression, { v: variables.getState() });
                const value = !!evaluated || !Number.isNaN(evaluated) ? evaluated : undefined;
                // assign only if truthy or not literally NaN
                runtime.trace.debug(`setting \`{${set.variable}}\`  \nevaluating \`${shuntingYard_1.regexExpression(set.expression)}\` to \`${(_a = value === null || value === void 0 ? void 0 : value.toString) === null || _a === void 0 ? void 0 : _a.call(value)}\``);
                variables.set(set.variable, value);
            }
            catch (error) {
                runtime.trace.debug(`unable to resolve expression \`${shuntingYard_1.regexExpression(set.expression)}\` for \`{${set.variable}}\`  \n\`${error}\``);
                await runtime.callEvent(Lifecycle_1.EventType.handlerDidCatch, { error });
            }
        });
        return node.nextId || null;
    },
});
exports.default = setHandler;
//# sourceMappingURL=set.js.map