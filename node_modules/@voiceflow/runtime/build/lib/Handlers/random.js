"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Constants_1 = require("../Constants");
const randomHandler = () => ({
    canHandle: (node) => !!node.random,
    handle: async (node, runtime) => {
        var _a, _b;
        let nextId;
        if (!node.nextIds.length) {
            runtime.trace.debug('no random paths connected - exiting');
            return null;
        }
        if (node.nextIds.length === 1) {
            [nextId] = node.nextIds;
        }
        else if (node.random === 2) {
            // no duplicates random node
            let used;
            const { storage } = runtime;
            if (!storage.get(Constants_1.S.RANDOMS)) {
                // initialize randoms
                storage.set(Constants_1.S.RANDOMS, {});
            }
            if ((_b = (_a = storage.get(Constants_1.S.RANDOMS)) === null || _a === void 0 ? void 0 : _a[node.id]) === null || _b === void 0 ? void 0 : _b.length) {
                used = new Set(storage.get(Constants_1.S.RANDOMS)[node.id]);
            }
            else {
                used = new Set();
                storage.set(Constants_1.S.RANDOMS, Object.assign(Object.assign({}, storage.get(Constants_1.S.RANDOMS)), { [node.id]: [] }));
            }
            // get all unused choices
            let choices = node.nextIds.filter((choice) => !used.has(choice));
            if (!choices.length) {
                // all choices have been used
                choices = node.nextIds;
                // reset used choices
                storage.set(Constants_1.S.RANDOMS, Object.assign(Object.assign({}, storage.get(Constants_1.S.RANDOMS)), { [node.id]: [] }));
            }
            nextId = choices[Math.floor(Math.random() * choices.length)];
            storage.set(Constants_1.S.RANDOMS, Object.assign(Object.assign({}, storage.get(Constants_1.S.RANDOMS)), { [node.id]: [...storage.get(Constants_1.S.RANDOMS)[node.id], nextId] }));
        }
        else {
            nextId = node.nextIds[Math.floor(Math.random() * node.nextIds.length)];
        }
        runtime.trace.debug('going down random path');
        return nextId;
    },
});
exports.default = randomHandler;
//# sourceMappingURL=random.js.map