"use strict";
/* eslint-disable no-unused-expressions */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const immer_1 = __importDefault(require("immer"));
class Store {
    constructor(payload = {}, { didUpdate, willUpdate } = {}) {
        this.store = {};
        this.store = Object.assign({}, payload);
        this.didUpdate = didUpdate;
        this.willUpdate = willUpdate;
    }
    static merge(store1, store2) {
        return new Store(Object.assign(Object.assign({}, store1.getState()), store2.getState()));
    }
    getState() {
        return this.store;
    }
    get(key) {
        return this.store[key];
    }
    has(key) {
        // eslint-disable-next-line no-prototype-builtins
        return this.store.hasOwnProperty(key);
    }
    update(nextState) {
        var _a, _b;
        const prevState = this.store;
        (_a = this.willUpdate) === null || _a === void 0 ? void 0 : _a.call(this, this.store, nextState);
        this.store = nextState;
        (_b = this.didUpdate) === null || _b === void 0 ? void 0 : _b.call(this, prevState, this.store);
    }
    produce(producer) {
        this.update(immer_1.default(this.store, producer));
    }
    merge(payload) {
        this.produce((draft) => Object.assign(draft, payload));
    }
    set(key, value) {
        this.produce((draft) => {
            draft[key] = value;
        });
    }
    delete(key) {
        this.produce((draft) => {
            delete draft[key];
        });
    }
    keys() {
        return Object.keys(this.store);
    }
    reduce(callback, initial) {
        return this.keys().reduce((acc, key, i) => callback(acc, { key, value: this.get(key) }, i), initial);
    }
    map(callback) {
        return this.reduce((acc, ...args) => [...acc, callback(...args)], []);
    }
    forEach(callback) {
        this.reduce((_, ...args) => [callback(...args)], []);
    }
    flush() {
        this.update({});
    }
}
Store.initialize = (store, keys, initialValue = 0) => {
    const keysToMerge = keys.reduce((acc, key) => {
        if (store.get(key) === undefined) {
            acc[key] = initialValue;
        }
        return acc;
    }, {});
    store.merge(keysToMerge);
};
exports.default = Store;
//# sourceMappingURL=index.js.map