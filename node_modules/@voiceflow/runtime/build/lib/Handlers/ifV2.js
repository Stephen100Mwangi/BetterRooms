"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const general_types_1 = require("@voiceflow/general-types/");
const flags_1 = require("../Constants/flags");
const code_1 = __importDefault(require("./code"));
const IfV2Handler = ({ _v1, safe }) => ({
    canHandle: (node) => {
        return node.type === general_types_1.NodeType.IF_V2;
    },
    handle: async (node, runtime, variables, program) => {
        var _a;
        if ((_a = runtime.turn.get(flags_1.TurnType.STOP_TYPES)) === null || _a === void 0 ? void 0 : _a.includes(general_types_1.NodeType.IF_V2)) {
            return _v1.handle(node, runtime, variables, program);
        }
        let outputPortIndex = -1;
        const setOutputPort = function (index) {
            outputPortIndex = index;
        };
        const debugErrors = [];
        const addDebugError = function (err) {
            debugErrors.push(err);
        };
        const codeHandler = code_1.default({ callbacks: { setOutputPort, addDebugError }, safe });
        let code = '';
        for (let i = 0; i < node.payload.expressions.length; i++) {
            const expression = node.payload.expressions[i];
            code += `
            try {
              if(eval(\`${expression}\`)) {
                setOutputPort(${i}); 
                throw(null);
              }
            } catch (err) {
              if (err != null) {
                addDebugError({ index: ${i + 1}, expression: \`${expression}\`, msg: err.toString() });
              } else {
                // matched - exit early
                throw(null);
              }
            }
        `;
        }
        const codeTemplate = `try { ${code} } catch (err) {}`;
        await codeHandler.handle({ code: codeTemplate, id: 'PROGRAMMATICALLY-GENERATED-CODE-NODE', type: general_types_1.NodeType.CODE }, runtime, variables, program);
        debugErrors.forEach((err) => runtime.trace.debug(`Error condition ${err.index} - "${err.expression}": ${err.msg}`));
        if (outputPortIndex !== -1) {
            runtime.trace.debug(`condition matched - taking path ${outputPortIndex + 1}`);
            return node.paths[outputPortIndex].nextID;
        }
        runtime.trace.debug('no conditions matched - taking else path');
        return node.payload.elseId || null;
    },
});
exports.default = IfV2Handler;
//# sourceMappingURL=ifV2.js.map