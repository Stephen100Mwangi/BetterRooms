"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Constants_1 = require("../Constants");
const Lifecycle_1 = require("../Lifecycle");
const cycleHandler_1 = __importDefault(require("./cycleHandler"));
const variables_1 = require("./utils/variables");
const STACK_OVERFLOW = 60;
const cycleStack = async (runtime, depth = 0) => {
    if (runtime.stack.getSize() === 0 || depth > STACK_OVERFLOW) {
        runtime.end();
        return;
    }
    const currentFrame = runtime.stack.top();
    const currentFrames = runtime.stack.getFrames();
    const program = await runtime.getProgram(currentFrame.getProgramID());
    // initialize frame with program properties
    currentFrame.initialize(program);
    // generate combined variable state (global/local)
    const combinedVariables = variables_1.createCombinedVariables(runtime.variables, currentFrame.variables);
    try {
        await runtime.callEvent(Lifecycle_1.EventType.stateWillExecute, { program, variables: combinedVariables });
        await cycleHandler_1.default(runtime, program, combinedVariables);
        await runtime.callEvent(Lifecycle_1.EventType.stateDidExecute, { program, variables: combinedVariables });
    }
    catch (error) {
        await runtime.callEvent(Lifecycle_1.EventType.stateDidCatch, { error });
    }
    // deconstruct variable state and save to stores
    variables_1.saveCombinedVariables(combinedVariables, runtime.variables, currentFrame.variables);
    // Action.END allows you to stay on the same frame and return a response
    if (runtime.hasEnded()) {
        return;
    }
    if (currentFrames === runtime.stack.getFrames()) {
        // pop frame
        const poppedFrame = runtime.stack.pop();
        await runtime.callEvent(Lifecycle_1.EventType.frameDidFinish, { frame: poppedFrame });
        const topFrame = runtime.stack.top();
        if ((poppedFrame === null || poppedFrame === void 0 ? void 0 : poppedFrame.storage.get(Constants_1.S.OUTPUT_MAP)) && topFrame) {
            variables_1.mapStores(poppedFrame.storage.get(Constants_1.S.OUTPUT_MAP), combinedVariables, topFrame.variables);
        }
    }
    await cycleStack(runtime, depth + 1);
};
exports.default = cycleStack;
//# sourceMappingURL=cycleStack.js.map