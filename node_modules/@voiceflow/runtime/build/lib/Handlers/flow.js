"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Constants_1 = require("../Constants");
const Frame_1 = __importDefault(require("../Runtime/Stack/Frame"));
const variables_1 = require("../Runtime/utils/variables");
const FlowHandler = () => ({
    canHandle: (node) => !!node.diagram_id,
    handle: (node, runtime, variables) => {
        var _a, _b, _c, _d;
        if (!node.diagram_id) {
            return node.nextId || null;
        }
        const newFrame = new Frame_1.default({ programID: node.diagram_id });
        // map node variable map input to frame
        variables_1.mapStores(((_a = node.variable_map) === null || _a === void 0 ? void 0 : _a.inputs) || [], variables, newFrame.variables);
        // TODO: remove storage
        // attach node variable map outputs to frame
        newFrame.storage.set(Constants_1.S.OUTPUT_MAP, (_c = (_b = 
        // adapt outputs format to [[currentVal, newVal]] - like inputs
        node.variable_map) === null || _b === void 0 ? void 0 : _b.outputs) === null || _c === void 0 ? void 0 : _c.map((val) => [val[1], val[0]]));
        const topFrame = runtime.stack.top();
        topFrame.setNodeID((_d = node.nextId) !== null && _d !== void 0 ? _d : null);
        runtime.stack.push(newFrame);
        runtime.trace.debug(`entering flow \`${newFrame.getProgramID()}\``);
        return null;
    },
});
exports.default = FlowHandler;
//# sourceMappingURL=flow.js.map